/*
Copyright ¬© 2025 Yby Team
*/
package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"github.com/spf13/cobra"
	"github.com/spf13/cobra/doc"
)

// genDocsCmd represents the gen-docs command
var genDocsCmd = &cobra.Command{
	Use:    "gen-docs [output-dir]",
	Short:  "Gera documenta√ß√£o Markdown para todos os comandos",
	Hidden: true, // Internal tool only
	Args:   cobra.MaximumNArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		outputDir := "./docs/wiki"
		if len(args) > 0 {
			outputDir = args[0]
		}

		if err := os.MkdirAll(outputDir, 0755); err != nil {
			fmt.Printf("‚ùå Erro criando diret√≥rio de sa√≠da: %v\n", err)
			os.Exit(1)
		}

		fmt.Printf("üìù Gerando documenta√ß√£o em '%s'...\n", outputDir)

		// Disable the "Auto generated by spf13/cobra" footer for cleaner docs
		rootCmd.DisableAutoGenTag = true

		err := doc.GenMarkdownTree(rootCmd, outputDir)
		if err != nil {
			fmt.Printf("‚ùå Erro gerando documenta√ß√£o: %v\n", err)
			os.Exit(1)
		}

		fmt.Println("‚úÖ Documenta√ß√£o gerada com sucesso!")

		// Update Sidebar
		if err := updateSidebar(outputDir); err != nil {
			fmt.Printf("‚ùå Erro atualizando Sidebar: %v\n", err)
			os.Exit(1)
		}
		fmt.Println("‚úÖ Sidebar atualizada!")
	},
}

func init() {
	rootCmd.AddCommand(genDocsCmd)
}

func updateSidebar(wikiDir string) error {
	sidebarPath := filepath.Join(wikiDir, "_Sidebar.md")
	startMarker := "<!-- CLI_REF_START -->"
	endMarker := "<!-- CLI_REF_END -->"

	// 1. List files
	files, err := os.ReadDir(wikiDir)
	if err != nil {
		return err
	}

	var links []string
	var filenames []string
	for _, f := range files {
		if !f.IsDir() && strings.HasPrefix(f.Name(), "yby") && strings.HasSuffix(f.Name(), ".md") {
			filenames = append(filenames, f.Name())
		}
	}
	sort.Strings(filenames)

	for _, f := range filenames {
		namePart := strings.TrimSuffix(f, ".md")
		underscoreCount := strings.Count(namePart, "_")

		// FILTER: Show only Top-Level commands (0 or 1 underscore)
		if underscoreCount > 1 {
			continue
		}

		name := strings.ReplaceAll(namePart, "_", " ")
		if name == "yby" {
			name = "yby (root)"
		}

		link := fmt.Sprintf("  - [%s](%s)", name, namePart)
		links = append(links, link)
	}

	// 2. Read Sidebar
	contentBytes, err := os.ReadFile(sidebarPath)
	if err != nil {
		// If not exists, create clean
		if os.IsNotExist(err) {
			contentBytes = []byte("")
		} else {
			return err
		}
	}
	content := string(contentBytes)

	// 3. Construct new section
	newSection := fmt.Sprintf("%s\n- **CLI Reference**\n%s\n%s",
		startMarker, strings.Join(links, "\n"), endMarker)

	// 4. Replace block
	if strings.Contains(content, startMarker) {
		re := regexp.MustCompile(fmt.Sprintf(`(?s)%s.*?%s`, regexp.QuoteMeta(startMarker), regexp.QuoteMeta(endMarker)))
		content = re.ReplaceAllString(content, newSection)
	} else {
		// Append handling (simplified for Go)
		if content != "" && !strings.HasSuffix(content, "\n") {
			content += "\n"
		}
		content += "\n" + newSection
	}

	return os.WriteFile(sidebarPath, []byte(content), 0644)
}
